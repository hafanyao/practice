01. post/get 缓存方面的区别
    - get 类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存
    - post 一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存
    - Post 数据不会记录存储在浏览器的记录和网址访问记录中，这样会有更大的安全性



02. axios 和 fetch 的区别
    - Fetch 的优势仅仅在于浏览器原生支持
    - Axios 是对 XMLHttpRequest 的封装，而 Fetch 是一种新的获取资源的接口方式，
        并不是对 XMLHttpRequest 的封装
    - 最大的不同点在于 Fetch 是浏览器原生支持，而 Axios 需要引入 Axios 库
    - 兼容性问题
        - Axios 可以兼容 IE，而 Fetch 在 IE 和一些 老版本浏览器 上没有受到支持
    - 传递数据的方式不同
        - Axios 是放到 data 属性里，以对象的方式进行传递
        - Fetch 则是需要放在 body 属性中，以字符串的方式进行传递
    - HTTP拦截器
        - Axios 的一大卖点就是它提供了拦截器
        - Fetch 没有拦截器功能，需要重写全局 Fetch 方法



03. HTTP2.0 多路复用和 HTTP1.X 长连接复用有什么区别？- 路白

    - HTTP/1.* 
        - 每个TCP连接只能发送一个请求，用完关闭；每一个请求都要建立一个tcp连接
    - HTTP/1.1 
        - 默认采用持续连接，TCP 默认不关闭，可以被多个请求复用，不用显示声明 keep-alive
        - 增加了管道机制，同一个 TCP 连接允许多个请求同时发送，增加了一定的并发性
        - 但是同一个 TCP 连接，所有通信是顺序执行的，一旦某个请求超时 后续请求被阻塞，也就是‘队头阻塞’
    - HTTP/2 
        - 双工模式，客户端能够同时发布多个请求，服务器也可以同时相应多个请求，解决了‘队头阻塞’
          某个请求任务耗时严重，不会影响到其它连接的正常执行
            - 多路复用: 同一个TCP连接上可以并发处理多个请求，支持二进制的格式，可以无序（stream ID）
            - header压缩: encoder 减少 header 大小，通讯双方各自 cache 一份 header-fields 表，避免了重复 header的传输
            - 服务端推送: 客户端可以主动向客户端发送数据。再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求
    - 多路复用：
        - 1.1 是同时发送但服务器只能处理一个，要排队
        - 2.0 是同时处理，服务器也是同时处理，不用等待上一个完成

        - 为什么 1.1 不能同时处理？
            - 1.1 基于文本分割解析的协议，文本从上向下执行，否则结果会乱序
            - 2.0 基于二进制侦的协议，侦内有标识属于哪一个流，结果不会乱序
    - HTTP2 缺点：
        - http2 多个请求在一个 TCP 管道中的，出现丢包时 HTTP2 的表现反倒不如 HTTP1.1
        - 因为 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求
        - 而对于 HTTP1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据

    - QUIC - 新的通讯协议 - http2 + TLS + UDP
        - 优点：
            1. 支持连接转移
            2. 减少 TCP 对头阻塞
            3. 灵活、安全、减少延迟
            4. 不需要建立 TCP 连接，通过其他数据包协商安全协议
            5. 数据吞吐方面 QUIC 更优秀，资源占用方面 TCP 优于 QUIC
            6. 相对于 UDP 提供了可靠传输，相对于 TCP 拥有更多的连接建立时间
            7. TCP => 100ms  -  TCP+TLS => 200-300ms  -  QUIC => 0-100ms
            
        - 特点：
            1. 使用 packet Number 单调递增，可以让数据包不再像 TCP 那样有序确认
            2. 基于网络拓扑运行，建立连接后‘源’/目标IP/端口都可以修改，不需要重新建立连接
            3. 连接是安全且加密的，TLS1.3 支持直接融入到协议中，所有 QUIC 流量都经过加密
            4. 为 UDP 添加了关键的流量控制和错误处理，包含重要安全机制以防止拒绝服务的攻击
            5. 添加了零往返 http 请求的支持，http 需要多次数据交换才能建立 TLS 会话，QUIC 允许 HTTP 标头作为 TLS 握手的一部分发送

        - QUIC 是如何实现可靠传输的呢
            - https://blog.csdn.net/m0_58687318/article/details/126724969

            1. 有序性：接收端能按序组装数据包，解码得到有效的数据
                - 每个 Stream 帧中都有 offset 字段和 StreamID 字段，使得乱序接收的数据能够有序排列
            2. 完整性：发送端发出的数据包，接收端都能收到
                - 发送端通过包号（PKN）和确认应答（SACK）确认发送数据完整性
                1. 客户端：发送 3 个数据包给服务器（PKN = 1，2，3）
                2. 服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2
                3. 客户端：重传第 2 个数据包（PKN=4）
                    - 尽管 QUIC 会重传数据包，但是新的数据包的 PKN 的继续递增的，即之前发送的数据包（PKN=2）和重传的 数据包（PKN=4），虽然数据一样，但包号不同。这也解决了 TCP 中，原始包和重传包的序列号一样带来的重传歧义问题
                    - 由于 TCP 原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属



04. 从浏览器地址栏输入url到请求返回发生了什么 - https://juejin.cn/post/7079357877650997284
    - url 解析
        - 为什么url要解析（是否合法、也就是编码)
            - 网络标准规定了 URL 只能是字母和数字，还有一些特殊符号
            - 不同浏览器中 URL 的编码方式
                1. Chrome 浏览器是 UTF-8 编码
                2. FireFox 浏览器是 UTF-8 编码
                3. IE9 默认情况下以 UTF-8 发送 URL
                4. 中文 Windows 环境下，本地编码为 GB2312
    - dns 解析进行 ip 查找
        - 浏览器不能直接通过域名找到对应 IP，所以要通过 DNS 解析
        - dns解析流程
            - 浏览器缓存
            - 本机操作系统缓存
            - 本地 hosts 文件
            - 路由器缓存 - 本地 dns 解析器有没有缓存
            - 区域运营商缓存
            - 去找根DNS服务器(全球13台，固定ip地址) 
                - 顺序：根域名服务器，顶级域名服务器，主域名服务器
            - 前端的dns优化，可以在html页面头部写入dns缓存地址
            - <meta http-equiv="x-dns-prefetch-control" content="on" />
            - <link rel="dns-prefetch" href="http://www.baidu.com" />
        - 在应用层封装 http 报文
        - 注意：根域名服务器只保存下一级域名服务器的相关信息，而非具体的域名服务对应的 IP 地址，网上很多博客在这一步骤会说，先在根域名服务器上寻找是否有域名对应的IP地址，如果没有再去查询一级域名服务器，这实际上是错误的

    - 建立 TCP 连接 - https://applnzi6vl27059.pc.xiaoe-tech.com/live_pc/l_62be9920e4b050af23967a1c
        - 在传输层建立 TCP 连接
        - 查找到 IP 之后，就是 http 协议的三次握手（以及后面会涉及到四次分手）
        - 三次握手
            - 是一种安全机制，主要是为了防止失效连接的再次请求会产生错误的通讯
            - 建立 TCP 连接的过程，前后端交互需要 3 个数据包，主要目的就是确认双方发送和接收正常
        - 两次握手可以吗
            - 第二次握手是服务端发包，此时不能确定客户端有接收的能力
                如果第二次握手报文丢失，客户端无法知道服务端序列号，TCP 的可靠性就无从谈起了
        - 什么握手三次，挥手四次
            - 握手的时候接收端是将 SYN+ACK 合并到一起，所以少了一次
    - 发送请求
        - 一个请求报文由请求行/请求头/空行/实体（Get 请求没有）组成。
            请求头由通用首部/请求首部/实体首部/扩展首部组成
    - 服务器响应请求
        - 返回资源包
    - 浏览器解析渲染页面
        - 处理 HTML 并构建 dom 树 - unicode 码
        - 处理 CSS 并构建 cssom 树
        - 将 dom 和 cssom 合并成一个渲染树
        - 根据渲染树布局，计算节点信息
        - 将节点渲染至屏幕
    - 请求结束，断开连接
        - 渲染完成后断开 TCP 连接
        - 但是目前 http1.1 之后都会默认开启持久化连接（keep-alive）



05. 三次握手

    - 这是一种安全机制，主要是为了防止失效连接的再次请求会产生错误的通讯
        
        - 例：比如第一次握手发生了延迟，客户端没有接受到来自服务端的反馈，客户端以为这次请求失败了，于是进行了第二次请求，这时候服务端接受到了第二次请求并返回确认报文，这样一来二次握手的通信便建立完成了，那么第一次延迟的请求便会置为无效，假设第一次请求在二次握手建立成功之后才到达服务器，那么服务器这时候是没有办法判断这个请求是否有效，服务器根据协议规则再次返回确认报文，这样原本只应该存在一次有效的请求就变成了两个
    
    - 三次握手增加了一次客户端再次确认的过程，可以避免这个问题，同时三次握手可以确认双发收发功能都正常
        
        1. 第一次：客户端确认可以发送请求（不确认自己的请求是否发送成功，发送数据是否正确），服务端确认自己可以接受请求（不确认数据是否正确，不确认自己是否可以发送请求，不确认请求数据是否正确）
        
        2. 第二次：客户端收到确认报文，确认自己可以发送请求，确认发送成功，确认数据正确，服务端确认自己可以接受请求，确认自己可以发送请求，（不确认数据是否正确，，不确认请求数据是否正确）
        
        3. 第三次：客户端收到确认报文，确认自己可以发送请求，确认发送成功，确认数据正确，服务端确认自己可以接受请求，确认自己可以发送请求，确认客户端可以接受自己发出的请求，确认自己发出的请求数据正确

    - 为什么挥手要 4 次
        
        - 因为既要确认即结束了链接又完成了数据发送；而建立只需要确认双方都在可以通讯就好了，不需要发送数据
        - 前两次挥手：客户端先结束发送并告知服务器断开，服务器确认后则结束接收，此时客户端还在接收服务端也在发送，所以需要服务端也发送一次告诉客户的自己也结束了，最后一次客户端确认双方关闭发送和接收并断开



06. TCP 和 UDP 的区别
    - TCP 只能 1 对 1，UDP 支持 1 对多
    - TCP 首部较大为 20 字节，UDP 只有 8 字节
    - TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，
        正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来
    - UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。
        它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
    UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境
    - TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）
    


07. 强制缓存 / 协商缓存 - ‘先强/后协商’
    - cache-control: max-age=xxxx，public
        - 客户端和代理服务器都可以缓存该资源；
        - 客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存, statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求

    - cache-control: max-age=xxxx，private
        - 只让客户端可以缓存该资源；代理服务器不缓存
        - 客户端在xxx秒内直接读取缓存, statu code:200

    - cache-control: max-age=xxxx，immutable
        - 客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存, statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

    - cache-control: no-cache（表示强制进行协商缓存）
        - 跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了 no-cache 就不会走强缓存了，每次请求都回询问服务端。

    - cache-control: no-store（表示禁止任何缓存策略）
        - 不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。


    - 协商缓存 - etag 和 last-modified
        - response header里面的设置 etag（etag 需要计算会有性能损耗）
        - etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一
        - 请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
        - 如果资源没更改，返回304，浏览器读取本地缓存。
        - 如果资源有更改，返回200，返回最新的资源。
        - 补充一点，response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名：
        
        - 304缓存的原理：服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改
        - 顺序 Cache-Control／Expires，再 ETag，最后 Last-Modified 都满足才 304
        - 设置强缓存相关字段有 expires，cache-control。cache-control 的优先级高于 expires
        - 协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match



08. WebSocket 和 HTTP 区别
    - 相同点
        a. 都是应用层协议
        b. 都是一样基于TCP的，都是可靠性传输协议
    - 不同点
        a. WebSocket 是双向通信协议，HTTP 是单向的
        b. WebSocket 是需要握手进行建立连接的(WebSocket是一种持久化的协议。基于HTTP协议完成一部分握手，HTTP握手部分完成，协议升级为WebSocket)。



09. http 和 https
    1. 可靠的协议，因为基于 TCP
    2. http 网站协议是明文未加密的会被劫持，传输隐私信息非常不安全（80）
    3. https ssl + http，加密传输 协议无法被解密所以无法注入，需要 CA 证书
        - a.建立信息安全通道，b.确认网站真实性（443）
        - 场景：家用计算机访问 http 网站会弹出广告
    4. HTTP 响应速度比 HTTPS 快
        - HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包
        - HTTPS 除了 TCP 的三个包，还要加上 ssl 握手的 9 个包，一共是 12 个包
    5. HTTPS 是建构在 SSL/TLS 之上的 HTTP 协议，比 HTTP 更耗费服务器资源
    6. 问：用户访问之前，公钥和私钥存在哪里
        - 答：服务器，用户访问之后会把私钥下载到本地



10. 301 和 302
    - 301 是永久重定向，而 302 是临时重定向
    - 301 常用场景是使用域名跳转
    - 302 用做临时跳转, 如未登录用户访问用户中心被重定向到登录页



11. 说网络分层里七层模型是哪七层
    应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    传输层（TCP和UDP）
    网络层（IP）
    物理和数据链路层（以太网）