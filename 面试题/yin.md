- 麓一

    如何给自己制定制定合理的学习计划，让自己处在“学习区”（舒适区、学习区、恐惧区）
    如何把知识有效内化，并洞悉领导、企业、市场、社会甚至国家的走向与导向，让技术快速变现



- vue3 优点：小、快
    - 源码/架构
        - 将 compiler 拆成了 4 个包，方便开发者重写
        - 使用 rollup 打包，更好的支持 treeshaking
        - Proxy 天生的代理数据侦变化，无需一层层递归为每个属 性添加代理
        - 采用了 monorepo 的方式，分层清晰，同时把编译部分也进行了一些拆解
    - diff 算法
        - 跳过不必要的条件分支
        - 只和动态节点数量相关
        - 增加了最大递增子序列的算法，移动节点更高效
        - blockTree 动态节点正相关，对比需要改变的节点来优化性能（jsx 不会优化，可以手动标记）
    - 编译内容
        - 静态提升，避免静态节点重复 render
        - patchFlag 标记哪些元素包裹哪些属性
        - sloat 插槽，父组件更新不再 render 子组件
        - 进行了重写，把 temelate -- render 函数重写了
        - vue2 基于正则，vue3基于状态机 -- ast 编译原理
        - 更多的编译时提示来减少运行时开销，使用更有效的代码来创建虚拟节点
    
    - composition API
        1. 优化逻辑组织
            - 将某个逻辑相关的代码全都放在一个函数里，当需要修改一个功能时，不需要关注其他代码
        2. 优化逻辑复用
            - Vue2.x 中通常会用 mixins 去复用逻辑，如果组件大就会数据来源不清晰，难以维护

    - 为什么 ts 重构（类型检测，可以单纯的看做 Type+JS）
        官网原文：
        - ts 这样的类型系统可以在构建时通过静态分析检测许多常见错误。减少了生产中出现运行时错误的机会，也使我们能够更自信地重构大规模应用程序中的代码。TypeScript 还通过 ide 中基于类型的自动完成来改进开发者的人体工程学。



- nextTick：
    - 本次循环的事情放到下一次循环去做，视图的下一次更新，
    - 也就是本次 updated 之后，所以实际是在 munted 之后
    - 本质是对 JavaScript 执行原理 EventLoop 的一种应用。
    - 核心是利用了如 Promise、MutationObserver、setImmediate、setTimeout 的原生 JavaScript 方法来模拟对应的微/宏任务的实现



- 某些情况下在 munted 中无法获取 dom，比如 dom 很大，
    因为 dom 渲染是需要时间跨度的，或者依赖数据/v-if 等



- conputed 和 watch 区别：- 云隐
    - 相同点：
        1. 底层实现都是基于 vue 依赖收集机制，
        2. 都是依赖数据的变化触发，进行改变进而进行处理计算

    - 不同点：
        1. 入和出
            conputed：多入单出 -> 多个值的变化组成一个值的变化
            watch：单入多出 -> 监听单个值的变化进而影响一系列的状态变更
        2. 性能
            conputed：会自动 diff 依赖，如果依赖没有变化则不会重新执行，从缓存中读取（缓存）
            watch：无论监听值变化与否，都会执行回调
        3. 语法
            conputed：必须有返回值
            watch：不一定需要返回值
        4. 时机
            conputed：实例生成挂在阶段就会执行，首次赋值就开始计算
            watch：首次不会执行，依赖项变化才会执行（首次执行设置：immediate：true）

    - watch
        1. 支持异步监听
        2. 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
        3. 监听数据必须是data中声明的或者父组件传递过来的props中的数据
            - immediate：组件加载立即触发回调函数
            - deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化（deep无法监听到数组和对象内部的变化）
        4. 当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。

    

- v-if 和 v-show
    - 频繁切换 v-show 更适合，单次渲染 v-if 更适合
    - v-if 和 v-for 优先级：vue2 for 高 -— vue3 if 高
    - v-if 和 v-show 性能优化：v-if 更高，因为 dom 少了，效率自然高
    - v-if 和 v-for 同时用，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
    - 在外层嵌套 template（渲染不生成dom），在这一层进行v-if判断，然后在内部进行 v-for

        
    
- diff 算法的四个指针：新前、旧前、新后、旧后
    - 同级对比，从两端向中间，通过 key 判断是否出现变化
    - 层级：只考虑单层复用，多层级遍历实现
    - 顺序：双向指针，首位向中间移动
    - 替换：移动、新增、删除，优先复用

    - diff 优化时间复杂度到O(n)
        - 之比较同级，不跨级比较
        - tag 不同则直接删除重建，不再深度比较
        - tag 和 key 两者都相同，则认为节点相同，不再深度比较
        - 都有 ch 则对；新 ch 有值，旧 ch 无值则添加；新无旧有则删除
        - 开始和开始；结束和结束；开始和结束；结束和开始

    - 区分静动态节点，只遍历动态节点，Vue2 中据发生变化就会生成新 DOM 树，全量的比较
    - Vue3 创建虚拟 DOM 树的时候，会根据 DOM 中的内容会不会发生变化，添加一个静态标记。只会对比这些带有静态标记的节点



- mixin - 混入
    1. 应用：抽离公共逻辑，逻辑一样，模版不一样
        合并策略：
            a. data 冲突则以主体为主，主体没有则显示 mixin 的数据
            b. 生命周期先执行 mixin 的钩子，再执行主体钩子
            c. 递归合并，递归合并优先级仍以主体为准
    2. 缺点：
        a. 数据来源不明确，不利于 debug，维护成本高



- extends - 继承拓展
    1. 应用：拓展独立逻辑
    2. 合并策略：与 mixin 相同
        a. 合并优先级，mixin 高于 extends
        b. 回调优先级，extends 高于 mixin

- extend - 整体拓展
    - 从预定义的角度拓展一个独立的配置项，并进行合并
    - main.js 拓展一个构造器，全局 data、钩子等



- mixin 和 extends：
    合并优先级 mixin 更高，回调优先级 extends 更高



- Vue双向绑定原理 - 路白
    - 见 Vue源码 / 理论.md

