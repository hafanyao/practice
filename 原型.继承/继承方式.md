### https://blog.csdn.net/More_Action/article/details/109844030

1. 原型链直接继承

    * 1. 父类属性一旦赋值给子类原型属性，此时就处于子类的共享属性
    * 2. 实例化子类时，无法向父类传惨
    - 所有对于原型链上属性的修改，都会变成通用调整
    - 缺点：引用类型数据会导致混乱 ————————————



2. 构造函数继承
    - 缺点：无法实现函数方法的复用，并且父类原型定义的方法子类也没有办法访问到



3. 组合继承
    - 原型链继承继承方法，构造函数继承继承属性（无法继承原型上的方法），加在一起就是组合继承 ***
    - 缺点：由于是以父类的实例来作为子类的原型，
      call()方法已经拿到父类所有的属性 ，后面再使用原型时也会有父类所有属性，所以调用了两次父类的构造函数，造成了多余的操作（实例化了2次）



4. 寄生组合继承
    - ***
    - 组合继承的缺点就是使用父类的实例做为子类的原型，导致添加了不必要的原型属性。
    - 寄生式组合继承的方式是使用父类的原型副本来作为子类原型，这样就避免了创建不必要的属性。



5. 普通函数和构造函数的区别 
    1. 调用方式不一样，普通函数直接调用，构造函数要用关键字 new 来调用
    2. 调用时，构造函数内部会创建一个新对象，就是实例，普通函数不会创建新对象 
    3. 构造函数默认返回创建的对象（也就是实例），普通函数的返回值由 return 语句决定 
    4. 构造函数内部的 this 指向实例，普通函数的 this 指向调用对象（默认为 window）
    5. 构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写



6. 什么是原型
    - 任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性 _proto_ 指向它的构造函数的 prototype 指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype， 只有函数才有 prototype
    - 原型链的核心就是依赖对象的 _proto_ 的指向，实质找的是构造函数的 prototype
    - 原型链：由各级父对象逐级继承形成的链式结构，顶层对象就是 Object.prototype => null