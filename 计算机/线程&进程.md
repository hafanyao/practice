01. 浏览器是多进程的
    1. GPU 进程：用于 3D 绘制等，最多一个
    2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
    3. Browser 进程：浏览器主进程，唯一，负责创建/销毁其它进程、资源下载/管理、界面展示、前进后退等
        浏览器渲染进程（浏览器内核）：内部是多线程的，
        每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等



02. 渲染进程（浏览器内核）
    - 浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：

    1. GUI 渲染线程：
        负责渲染页面、布局，重绘和回流时该线程就会执行，与 js 引擎线程互斥，防止渲染结果不可预期
    2. JS 引擎线程：
        也称为 JS 内核，负责处理 JS 脚本程序、解析 JS 脚本、运行代码等（例如 V8 引擎）
    3. 事件触发线程：
        控制浏览器事件循环，注意这不归 JS 引擎线程管，事件被触发时，该线程会把事件添加到待处理队列队尾，等待 JS 引擎的处理
    4. 定时触发器线程：
        setInterval 与 setTimeout 所在线程，setTimeout 中低于 4ms 的时间间隔算为 4ms（循环嵌套超过5层的，并且延迟不到4ms，才会变成4ms）
    5. 异步 http 请求线程：
        XMLHttpRequest 连接后浏览器新开一个线程请求，检测到状态变更时，如果有回调函数，异步线程就产生状态变更事件，将这个回调放入事件队列中，由 JS 引擎执行



03. CPU、进程、线程 - 单线程的JS为什么拥有异步的能力（浏览器是多进程的）
    <!-- https://juejin.cn/post/6844903919789801486 -->
    - 所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间只能执行一项任务 ***
    - 计算机的核心是CPU，它承担了所有的计算任务，单个CPU一次只能运行一个任务
    - 进程之间相互独立，任一时刻CPU总是运行一个进程，CPU使用‘时间片轮转进度算法’实现同时运行多个进程
    - 根本区别
        - 不同进程之间也可以通信，不过代价较大
        - 单线程与多线程，都是指在一个进程内的单和多
        - 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
        - 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
    - 资源开销
        - 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；
        - 线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小
    - 包含关系
        - 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程
    - 内存分配
        - 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
    - 影响关系
        - 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程要比多线程健壮

    - 浏览器是多进程的，每一个Tab页，就是一个独立的进程
        - 浏览器包含了哪些进程：主进程、第三方插件进程、GPU进程（用于3D绘制）、渲染进程（浏览器内核）
    - 对于渲染进程来说，它当然也是多线程的
        - GUI 渲染线程：负责渲染页面、重绘和回流、与 JS 引擎线程互斥
        - JS 引擎线程：解析和执行 JS、只有一个 JS 引擎线程、与 GUI 互斥
        - 事件触发线程：控制事件循环、满足触发条件时将事件放入到 JS 执行队列中
        - 定时触发器线程：setInterval 与 setTimeout 所在的线程、由定时触发线程来计时
        - 异步 http 线程：浏览器有一个单独的线程用于处理 AJAX、完成时回调通知事件触发线程
    - GUI/JS 执行顺序
        - JS 引擎线程执行时 GUI 渲染线程会被挂起，GUI 更新会被保存在一个队列中等待 JS 引擎线程空闲时执行
    - eventLoop（关键词：执行栈、任务队列、JS引擎线程只执行执行栈）
        1. 同步任务都在JS引擎线程上执行，形成一个‘执行栈’
        2. 事件触发线程管理一个任务队列，异步任务触发条件达成，将回调事件放到‘任务队列’中
        3. 执行栈中同步任务执行完毕，JS 引擎线程空闲，系统读取任务队列，将异步任务回调事件添加到执行栈中执行
    - 宏任务 和 DOM
        为了使宏任务和 DOM 任务有序进行，会在一个宏任务执行后，下一个宏任务执行前，GUI 渲染线程对页面进行渲染
        ( 宏任务-->微任务-->渲染-->宏任务-->微任务-->渲染 ) 
        ```js
            document.body.style = 'background:red' // 宏任务
            Promise.resolve().then(() => {
                document.body.style = 'background:green'
            })
            <!-- 
                结果：document 直接变成绿色，这个例子清楚诠释了 ‘宏任务-->微任务-->渲染’
                    当前事件循环全部执行完才触发页面渲染，渲染时 GUI 线程会将所有 UI 改动优化合并
             -->
        ```


