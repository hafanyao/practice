<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js设计模式 - yin</title>
</head>
<body>
    <!--

        https://juejin.cn/post/6844904138707337229
        https://juejin.cn/post/6871098899960971278

        // 命令式：
        trim(reverse(toUpperCase(map(arr))))

        // 面向对象：
        arr.map().toUpperCase().reverse().trim()

        // 函数式：
        const result = compose(trim, reverse, toUpperCase, map)


        
        工厂模式：批量生产同类型应用
        建造者模式：元功能模块化解偶，重于频繁编排时
        单例模式：全局只要一个实例，注重一体化，vue-router
        适配器模式：适配已有的方案（220W 电压适配 110W 电器）
        装饰器模式：增强已有方案，批量提供/提升相应功能
        代理模式：把调用方与被调用方分离，不直接产生调用关系
        命令模式：通过固定渠道/媒介去产生沟通（Vuex - mutations/action）
        模板模式：易拓展（echarts），在模板中定义好模块最简单的说明书
        观察者模式：模块间实时互通（输入框内容变化，下拉框内容随之变化 - vue）
        职责链(链式执行)：单向链形式的执行（节点相斥/链式相连，职责单元链式执行）
        


        函数式编程原则：
            1. 开闭原则：允许拓展，不允许修改
            2. 单一职责原则：岗位职责单一，且互不重叠
            3. 依赖倒置原则：上层实现不应该依赖下层细节
            4. 接口隔离原则：对外沟通通道
            5. 里氏替换原则：子类可以拓展功能，但不应改变功能
            注：组合 —— 声明式数据流 —— 是支撑函数式编程最重要的工具之一



        // —————————————— 创建类 - 创建元素 ——————————————

            1. 工厂模式：生产同类型商品
                - 隐藏创建过程，暴露共同接口
                - 工厂是有职责边界的

                
            2. 建造者模式：独立堆砌商品
                a. 拆分简单模块，独立职责运行 - 注重过程与搭配
                b. 模块的抽象与独立解偶
                c. 建造者负责创建串联整体
            
            工作流/数据流/工单/流程转换系统底层架构思路：***
                每个流程都是编排的改变，而不是原功能的改变，
                原功能稳定不变，可以独立拓展，他们的关系都是在建造/构建，也就是编排思想


            3. 单例模式：vue-router
                    特点：全局只有一个实例，
                        以单个去保障整个系统的唯一性
                        同一个时间点只有一个实例在跑


        面试：
            1. 三种类型什么时候用
                - 批量生产同类型应用来满足频繁使用同一类型素材时 - 工厂模式
                - 当我们可以将元功能模块化解偶，并且重于频繁编排时 - 建造者模式
                - 全局只要一个实例，注重的是一体化，且状态统一 - 单例模式

            2. 请举例
                - Button Producer：生产不同类型的按钮 -> 传参不同生产不同状态类型的按钮 —— 工厂模式
                - 页面组件 Header：包含 - title + button + breadcum -> 生产多种不同元素组合 —— 建造者模式
                - router/store：只需要一个实例 —— 单例模式


        // —————————————— 结构性 - 代码结构 ——————————————

            1. 适配器模式：适配已有的方案（220W电压适配110W电器）
                功能：优化结构的实现方式 => 处理方案
                    - 适配独立模块，保证模块间的独立解偶且连接兼容


            2. 装饰器模式：增强已有方案
                功能：动态将责任附加于对象之上
                    - 120 平的房子，装修完变成漂亮的 120，而不是变成 180
                    - 独立的逻辑外壳，将传入的逻辑做统一化处理
                    - 已有方案与后续需求的优雅迭代


            3. 代理模式：集约方案 - proxy/Object.defineproperty
                例：现有需求从 A=>B，产品要求 A=>C=>B，C 就是代理
                - 启用了代理人作为原路径的目标方
                - 不影响初始方的体验


            使用场景：
                - 中间参数转换，适配/兼容已有方案 - 适配器
                - 在已有方案中，批量提供/提升相应功能 - 装饰器
                - 当把调用方与被调用方分离，不直接产生调用关系 - 代理模式
            例：
                筛选器 联动 表格 => 中间增加适配器做数据结构的转换 => 适配已有方案工作
                button、title、breadcum => 三个组件同时具有发生改变、触发页面更新的功能 => 装饰器模式
                ul => lis，在 ul 上监听 => 代理模式
        
        
        
        // —————————————— 行为性 - 注重逻辑过程 ——————————————

            - 把不同对象间划分责任并实现逻辑

            1. 命令模式：通过媒介包裹命令
                请求以一种命令的形式包裹起来，并且由发起方传递给实施的一种流程
                接受者（游戏机） -> 操作者（人） -> 指令（手柄）
                实体间通过一个固定的渠道/媒介去产生沟通（Vuex 中的 mutations 和 action）


            2. 模板模式：易拓展（echarts）
                在模板中定义好模块最简单的说明书


            3. 观察者模式：模块间实时互通
                当一个属性发生变化时，观察者会连续引发相关状态触发相应逻辑的改变（一方变化去通知令一方）
                优势：及时、定向
                demo：输入框内容变化，下拉框内容随之变化


            4. 职责链(链式执行)：单向链形式的执行
                三大特点：链式调用、职责独立、顺序执行
                demo：老爸需要我扫地吗？老妈需要我洗碗吗？老婆需要我按摩吗？都通过才去 do something
                节点相斥，节点链式相连，独立职责单元链式执行，逐步操作流程

    -->
    
</body>
</html>